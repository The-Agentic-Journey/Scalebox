#!/bin/bash
set -euo pipefail

# === Configuration ===
# Config directory (can be overridden for testing)
SCALEBOX_CONFIG_DIR="${SCALEBOX_CONFIG_DIR:-$HOME/.config/scalebox}"
SCALEBOX_CONFIG_FILE="$SCALEBOX_CONFIG_DIR/config"

# Load config from multiple sources (in precedence order)
load_config() {
  # 1. Environment variables (highest priority) - already set
  # 2. User config file
  if [[ -z "${SCALEBOX_HOST:-}" || -z "${SCALEBOX_TOKEN:-}" ]] && [[ -f "$SCALEBOX_CONFIG_FILE" ]]; then
    # shellcheck source=/dev/null
    source "$SCALEBOX_CONFIG_FILE"
  fi
  # 3. System config file (lowest priority, for server-side usage)
  if [[ -z "${SCALEBOX_HOST:-}" ]] && [[ -f /etc/scalebox/config ]]; then
    SCALEBOX_HOST="http://localhost:8080"
    if [[ -z "${SCALEBOX_TOKEN:-}" ]]; then
      SCALEBOX_TOKEN=$(grep -E "^API_TOKEN=" /etc/scalebox/config 2>/dev/null | cut -d= -f2- || true)
    fi
  fi
  # 4. Legacy environment variable support
  if [[ -n "${SCALEBOX_URL:-}" && -z "${SCALEBOX_HOST:-}" ]]; then
    SCALEBOX_HOST="$SCALEBOX_URL"
  fi
}

# === Helpers ===
die() { echo "Error: $1" >&2; exit 1; }
need_jq() { command -v jq &>/dev/null || die "jq is required. Install with: apt install jq (or brew install jq)"; }
need_config() {
  [[ -n "${SCALEBOX_HOST:-}" ]] || die "Not logged in. Run 'sb login' first or set SCALEBOX_HOST."
  [[ -n "${SCALEBOX_TOKEN:-}" ]] || die "No token configured. Run 'sb login' first or set SCALEBOX_TOKEN."
}

# === SSH Key Management ===
# Generate SSH key if not present, validate if exists
ensure_ssh_key() {
  local key_file="$SCALEBOX_CONFIG_DIR/id_ed25519"
  local pub_file="${key_file}.pub"

  # Check if both files exist
  if [[ -f "$key_file" && -f "$pub_file" ]]; then
    # Fix permissions FIRST (ssh-keygen -l may fail if permissions are wrong)
    chmod 600 "$key_file" 2>/dev/null || true
    chmod 644 "$pub_file" 2>/dev/null || true

    # Then validate key format
    if ssh-keygen -l -f "$key_file" &>/dev/null; then
      return 0
    else
      echo "Warning: Existing SSH key is invalid, regenerating..." >&2
      rm -f "$key_file" "$pub_file"
    fi
  elif [[ -f "$key_file" || -f "$pub_file" ]]; then
    # One file exists but not the other - corrupted state
    echo "Warning: Incomplete SSH key pair, regenerating..." >&2
    rm -f "$key_file" "$pub_file"
  fi

  # Generate new key
  echo "Generating SSH key for Scalebox..." >&2
  mkdir -p "$SCALEBOX_CONFIG_DIR" || die "Failed to create config directory"
  chmod 700 "$SCALEBOX_CONFIG_DIR" || die "Failed to set config directory permissions"

  if ! ssh-keygen -t ed25519 -f "$key_file" -N "" -C "scalebox" >/dev/null 2>&1; then
    die "Failed to generate SSH key"
  fi

  chmod 600 "$key_file" || die "Failed to set private key permissions"
  chmod 644 "$pub_file" || die "Failed to set public key permissions"
}

# Get public key content
get_ssh_pubkey() {
  local key_file="$SCALEBOX_CONFIG_DIR/id_ed25519.pub"
  ensure_ssh_key
  cat "$key_file"
}

# Get private key path
get_ssh_keyfile() {
  local key_file="$SCALEBOX_CONFIG_DIR/id_ed25519"
  ensure_ssh_key
  echo "$key_file"
}

# Extract hostname from SCALEBOX_HOST URL
get_ssh_host() {
  # Extract hostname from URL, handling:
  # - Protocol: https://host -> host
  # - Auth: user:pass@host -> host
  # - Port: host:8080 -> host
  # - Path: host/path -> host
  local host="$SCALEBOX_HOST"
  host="${host#*://}"      # Remove protocol
  host="${host##*@}"       # Remove userinfo (user:pass@)
  host="${host%%:*}"       # Remove port (keep first part before :)
  host="${host%%/*}"       # Remove path
  echo "$host"
}

# === API Client ===
api() {
  local method=$1 path=$2; shift 2
  local response http_code
  local insecure_flag=""
  [[ "${SCALEBOX_INSECURE:-}" == "1" ]] && insecure_flag="-k"

  # Capture both response body and HTTP status code
  # Note: Don't use -f flag as it prevents capturing error response bodies
  response=$(curl $insecure_flag -s -w "\n%{http_code}" -X "$method" \
    -H "Authorization: Bearer $SCALEBOX_TOKEN" \
    -H "Content-Type: application/json" \
    "$@" "${SCALEBOX_HOST}${path}" 2>/dev/null)

  # Check if curl itself failed (connection error, etc)
  if [[ -z "$response" ]]; then
    echo '{"error":"Connection failed","status":0}'
    return 1
  fi

  http_code=$(echo "$response" | tail -n1)
  response=$(echo "$response" | sed '$d')

  # Validate we got a numeric HTTP code
  if ! [[ "$http_code" =~ ^[0-9]+$ ]]; then
    echo '{"error":"Connection failed","status":0}'
    return 1
  fi

  if [[ "$http_code" -ge 200 && "$http_code" -lt 300 ]]; then
    echo "$response"
    return 0
  else
    # Return error with status code for --json mode
    if [[ -n "$response" ]]; then
      echo "$response" | jq -c ". + {status: $http_code}" 2>/dev/null || echo "{\"error\":\"HTTP $http_code\",\"status\":$http_code}"
    else
      echo "{\"error\":\"HTTP $http_code\",\"status\":$http_code}"
    fi
    return 1
  fi
}

# === Output Formatting ===
JSON_OUTPUT="${SCALEBOX_JSON:-false}"

output_table() {
  local jq_filter="$1"
  local header="${2:-}"
  if [[ "$JSON_OUTPUT" == "true" ]]; then
    jq .
  else
    if [[ -n "$header" ]]; then
      { echo -e "$header"; jq -r "$jq_filter"; } | column -t 2>/dev/null || cat
    else
      jq -r "$jq_filter" | column -t 2>/dev/null || cat
    fi
  fi
}

output_single() {
  if [[ "$JSON_OUTPUT" == "true" ]]; then
    jq -c .
  else
    jq .
  fi
}

output_message() {
  local message="$1"
  if [[ "$JSON_OUTPUT" == "true" ]]; then
    jq -n --arg msg "$message" '{message: $msg}'
  else
    echo "$message"
  fi
}

output_error() {
  local message="$1"
  local status="${2:-1}"
  if [[ "$JSON_OUTPUT" == "true" ]]; then
    jq -n --arg msg "$message" --argjson status "$status" '{error: $msg, status: $status}'
  else
    echo "Error: $message" >&2
  fi
  return 1
}

# === Commands ===

cmd_login() {
  local host="" token="" token_stdin=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --host) host="$2"; shift 2 ;;
      --token-stdin) token_stdin=true; shift ;;
      *) die "Unknown option: $1" ;;
    esac
  done

  # Interactive mode if host not provided
  if [[ -z "$host" ]]; then
    echo -n "Scalebox host URL: "
    read -r host
  fi
  [[ -n "$host" ]] || die "Host URL is required"

  # Validate URL format (basic check)
  [[ "$host" =~ ^https?:// ]] || die "Host must start with http:// or https://"

  # Remove trailing slash
  host="${host%/}"

  # Get token
  if [[ "$token_stdin" == "true" ]]; then
    read -r token
  else
    echo -n "API token: "
    read -rs token
    echo  # newline after hidden input
  fi
  [[ -n "$token" ]] || die "Token is required"

  # Test connection
  echo "Testing connection..."
  local insecure_flag=""
  [[ "${SCALEBOX_INSECURE:-}" == "1" ]] && insecure_flag="-k"
  if ! curl $insecure_flag -sf -H "Authorization: Bearer $token" "$host/health" >/dev/null 2>&1; then
    die "Failed to connect to $host. Check the URL and token."
  fi

  # Create config directory with secure permissions
  # Note: mkdir -p creates parent dirs (e.g., ~/.config) if they don't exist
  mkdir -p "$SCALEBOX_CONFIG_DIR"
  chmod 700 "$SCALEBOX_CONFIG_DIR"

  # Write config with secure permissions
  (
    umask 077
    cat > "$SCALEBOX_CONFIG_FILE" <<EOF
SCALEBOX_HOST=$host
SCALEBOX_TOKEN=$token
EOF
  )

  output_message "Logged in to $host"
}

cmd_logout() {
  if [[ -f "$SCALEBOX_CONFIG_FILE" ]]; then
    rm -f "$SCALEBOX_CONFIG_FILE"
    output_message "Logged out (config removed)"
  else
    output_message "Not logged in (no config file)"
  fi
}

cmd_config_show() {
  local show_token=false
  [[ "${1:-}" == "--show-token" ]] && show_token=true

  local display_token
  if [[ "$show_token" == "true" ]]; then
    display_token="${SCALEBOX_TOKEN:-}"
  else
    # Mask token: show first 6 and last 4 chars
    if [[ -n "${SCALEBOX_TOKEN:-}" && ${#SCALEBOX_TOKEN} -gt 10 ]]; then
      display_token="${SCALEBOX_TOKEN:0:6}...${SCALEBOX_TOKEN: -4}"
    else
      display_token="${SCALEBOX_TOKEN:-}"
    fi
  fi

  if [[ "$JSON_OUTPUT" == "true" ]]; then
    jq -n \
      --arg host "${SCALEBOX_HOST:-}" \
      --arg token "$display_token" \
      --arg config_dir "$SCALEBOX_CONFIG_DIR" \
      '{host: $host, token: $token, config_dir: $config_dir}'
  else
    echo "Host:       ${SCALEBOX_HOST:-<not set>}"
    echo "Token:      ${display_token:-<not set>}"
    echo "Config dir: $SCALEBOX_CONFIG_DIR"
    if [[ -f "$SCALEBOX_CONFIG_FILE" ]]; then
      echo "Config file: $SCALEBOX_CONFIG_FILE (exists)"
    else
      echo "Config file: $SCALEBOX_CONFIG_FILE (not found)"
    fi
  fi
}

cmd_status() {
  local response
  local insecure_flag=""
  [[ "${SCALEBOX_INSECURE:-}" == "1" ]] && insecure_flag="-k"
  if response=$(curl $insecure_flag -sf "${SCALEBOX_HOST:-http://localhost:8080}/health" 2>/dev/null); then
    if [[ "$JSON_OUTPUT" == "true" ]]; then
      echo "$response" | jq -c '. + {status: 200}'
    else
      echo "$response" | jq .
    fi
  else
    output_error "Cannot connect to ${SCALEBOX_HOST:-http://localhost:8080}" 0
  fi
}

cmd_vm_list() {
  need_config
  local response
  if response=$(api GET /vms); then
    # Note: adds .name column (not in old scalebox CLI which showed: id, template, ip, ssh_port)
    echo "$response" | output_table '.vms[] | [.name, .id, .template, .ip, .ssh_port] | @tsv' $'NAME\tID\tTEMPLATE\tIP\tPORT'
  else
    echo "$response"
    return 1
  fi
}

cmd_vm_create() {
  need_config
  local template="" key="" key_file=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -t|--template) template="$2"; shift 2 ;;
      -k|--key)
        if [[ "$2" == @* ]]; then
          # @filepath syntax - read from file
          key_file="${2:1}"
          # Expand tilde if HOME is set (bash doesn't expand ~ inside quotes)
          if [[ -n "${HOME:-}" ]]; then
            key_file="${key_file/#\~/$HOME}"
          fi
          [[ -f "$key_file" ]] || die "Key file not found: $key_file"
          key=$(cat "$key_file")
        else
          key="$2"
        fi
        shift 2
        ;;
      *) die "Unknown option: $1" ;;
    esac
  done

  [[ -n "$template" ]] || die "Template required: -t TEMPLATE"

  # Use managed key if none provided
  if [[ -z "$key" ]]; then
    key=$(get_ssh_pubkey)
  fi

  local response
  if response=$(api POST /vms -d "$(jq -n --arg t "$template" --arg k "$key" '{template:$t,ssh_public_key:$k}')"); then
    echo "$response" | output_single
  else
    echo "$response"
    return 1
  fi
}

cmd_vm_get() {
  need_config
  local id="${1:-}"
  [[ -n "$id" ]] || die "Usage: sb vm get <name|id>"

  local response
  if response=$(api GET "/vms/$id"); then
    echo "$response" | output_single
  else
    echo "$response"
    return 1
  fi
}

cmd_vm_delete() {
  need_config
  local id="${1:-}"
  [[ -n "$id" ]] || die "Usage: sb vm delete <name|id>"

  local response
  if response=$(api DELETE "/vms/$id"); then
    output_message "Deleted $id"
  else
    echo "$response"
    return 1
  fi
}

cmd_vm_snapshot() {
  need_config
  local id="${1:-}"
  local name=""
  shift || true

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n|--name) name="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done

  [[ -n "$id" ]] || die "Usage: sb vm snapshot <name|id> -n TEMPLATE_NAME"
  [[ -n "$name" ]] || die "Template name required: -n NAME"

  local response
  if response=$(api POST "/vms/$id/snapshot" -d "$(jq -n --arg n "$name" '{template_name:$n}')"); then
    echo "$response" | output_single
  else
    echo "$response"
    return 1
  fi
}

cmd_vm_wait() {
  need_config
  local id="${1:-}"
  local wait_ssh=false
  local timeout=60
  shift || true

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --ssh) wait_ssh=true; shift ;;
      --timeout) timeout="$2"; shift 2 ;;
      *) die "Unknown option: $1" ;;
    esac
  done

  [[ -n "$id" ]] || die "Usage: sb vm wait <name|id> --ssh [--timeout SECONDS]"
  [[ "$wait_ssh" == "true" ]] || die "Must specify --ssh (only supported wait condition)"

  # Get VM details
  local vm_data ssh_port
  vm_data=$(api GET "/vms/$id") || die "VM not found: $id"
  ssh_port=$(echo "$vm_data" | jq -r '.ssh_port')

  # Extract host from SCALEBOX_HOST (remove protocol and port)
  local ssh_host
  ssh_host=$(echo "$SCALEBOX_HOST" | sed -E 's|^https?://||; s|:[0-9]+$||')

  local start=$SECONDS
  while (( SECONDS - start < timeout )); do
    if nc -z -w1 "$ssh_host" "$ssh_port" 2>/dev/null; then
      output_message "SSH ready on port $ssh_port"
      return 0
    fi
    sleep 1
  done

  output_error "Timeout waiting for SSH on port $ssh_port after ${timeout}s" 1
}

cmd_connect() {
  need_config
  local id="${1:-}"
  shift || true

  local user="root"
  local identity=""
  local use_ssh=false
  local ssh_opts=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --ssh) use_ssh=true; shift ;;
      -l|--user) user="$2"; shift 2 ;;
      -i|--identity)
        identity="$2"
        # Expand tilde if HOME is set (bash doesn't expand ~ inside quotes)
        if [[ -n "${HOME:-}" ]]; then
          identity="${identity/#\~/$HOME}"
        fi
        shift 2
        ;;
      -o) ssh_opts+=("-o" "$2"); shift 2 ;;
      --) shift; ssh_opts+=("$@"); break ;;  # Pass remaining args to SSH
      *) die "Unknown option: $1. Use -- to pass args to SSH." ;;
    esac
  done

  [[ -n "$id" ]] || die "Usage: sb connect <name|id> [--ssh] [-l USER] [-i KEYFILE] [-- SSH_ARGS...]"

  # Use managed key if none provided
  if [[ -z "$identity" ]]; then
    identity=$(get_ssh_keyfile)
  fi

  # Get VM details
  local vm_data ssh_port
  vm_data=$(api GET "/vms/$id") || { echo "$vm_data"; return 1; }
  ssh_port=$(echo "$vm_data" | jq -r '.ssh_port')

  # Extract host from SCALEBOX_HOST
  local ssh_host
  ssh_host=$(get_ssh_host)

  # Common SSH options for ephemeral VMs:
  # - StrictHostKeyChecking=accept-new: Accept new keys, warn on changes
  # - UserKnownHostsFile=/dev/null: Don't pollute known_hosts with ephemeral VM keys
  local base_ssh_opts="-o StrictHostKeyChecking=accept-new -o UserKnownHostsFile=/dev/null"

  if [[ "$use_ssh" == "true" ]]; then
    # Direct SSH connection (fallback if mosh doesn't work)
    # Note: ${ssh_opts[@]+...} handles empty array on bash 3.2 (macOS) with set -u
    exec ssh -p "$ssh_port" -i "$identity" $base_ssh_opts ${ssh_opts[@]+"${ssh_opts[@]}"} "${user}@${ssh_host}"
  else
    # Check mosh is installed locally
    if ! command -v mosh &>/dev/null; then
      echo "mosh not installed locally, falling back to SSH..." >&2
      echo "Install mosh for better experience: apt install mosh (or brew install mosh)" >&2
      exec ssh -p "$ssh_port" -i "$identity" $base_ssh_opts ${ssh_opts[@]+"${ssh_opts[@]}"} "${user}@${ssh_host}"
    fi

    # Note: If mosh-server is missing on the VM, mosh will fail with:
    #   "mosh-server: command not found"
    # This shouldn't happen with debian-base (Phase 5 installs mosh),
    # but custom templates might not have it. Use --ssh fallback in that case.

    # Build SSH command for mosh
    # Use printf %q to safely quote paths with spaces for shell expansion inside mosh --ssh
    local quoted_identity
    quoted_identity=$(printf '%q' "$identity")
    local ssh_cmd="ssh -p ${ssh_port} -i ${quoted_identity}"
    ssh_cmd+=" -o StrictHostKeyChecking=accept-new -o UserKnownHostsFile=/dev/null"
    # Note: ${ssh_opts[@]+...} handles empty array on bash 3.2 (macOS) with set -u
    for opt in ${ssh_opts[@]+"${ssh_opts[@]}"}; do
      ssh_cmd+=" $(printf '%q' "$opt")"
    done

    # Connect via mosh
    # --port tells mosh-server which port to use AND which port client connects to
    exec mosh --ssh="$ssh_cmd" --port="$ssh_port" "${user}@${ssh_host}"
  fi
}

cmd_template_list() {
  need_config
  local response
  if response=$(api GET /templates); then
    echo "$response" | output_table '.templates[] | [.name, ((.size_bytes / 1073741824 * 10 | floor) / 10 | tostring + " GB")] | @tsv' $'NAME\tSIZE'
  else
    echo "$response"
    return 1
  fi
}

cmd_template_delete() {
  need_config
  local name="${1:-}"
  [[ -n "$name" ]] || die "Usage: sb template delete <name>"

  local response
  if response=$(api DELETE "/templates/$name"); then
    output_message "Deleted template $name"
  else
    echo "$response"
    return 1
  fi
}

cmd_version() {
  echo "sb version 0.2.0"
}

cmd_help() {
  cat <<'EOF'
Scalebox CLI

Usage: sb [--json] <command>

Global Options:
  --json          Output in JSON format (for scripting)

Commands:
  login                         Log in to a Scalebox server
  logout                        Remove stored credentials
  config show [--show-token]    Show current configuration
  status                        Health check (no auth required)

  vm list                       List VMs
  vm create -t TPL [-k KEY]     Create VM (uses managed key if -k omitted)
  vm get <name|id>              Get VM details
  vm delete <name|id>           Delete VM
  vm snapshot <name|id> -n NAME Snapshot VM to template
  vm wait <name|id> --ssh       Wait for SSH to be ready

  connect <name|id> [options]   Connect to VM via mosh (or SSH with --ssh)
    Options:
      --ssh                     Force SSH instead of mosh
      -l, --user USER           Connect as USER (default: root)
      -i, --identity FILE       Use specific SSH key
      --                        Pass remaining args to SSH

  template list                 List templates
  template delete <name>        Delete template

  version                       Show version
  help                          Show this help

Environment Variables:
  SCALEBOX_HOST        API host URL (overrides config file)
  SCALEBOX_TOKEN       API token (overrides config file)
  SCALEBOX_CONFIG_DIR  Config directory (default: ~/.config/scalebox)
  SCALEBOX_JSON=true   Always output JSON
  SCALEBOX_INSECURE=1  Skip TLS verification (for testing with staging certs)

Examples:
  sb login
  sb vm create -t debian-base
  sb vm list
  sb connect my-vm-name
  sb connect my-vm-name --ssh
  sb --json vm get my-vm-name
  sb vm wait my-vm-name --ssh --timeout 120
  sb vm snapshot my-vm-name -n my-snapshot
EOF
}

# === Main ===
main() {
  need_jq

  # Parse global options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json) JSON_OUTPUT=true; shift ;;
      -*)
        if [[ "$1" != "--help" && "$1" != "-h" ]]; then
          die "Unknown global option: $1"
        fi
        break
        ;;
      *) break ;;
    esac
  done

  # Load config after parsing global options (but before commands)
  # Skip loading for login/help/version commands
  case "${1:-help}" in
    login|help|--help|-h|version) ;;
    *) load_config ;;
  esac

  case "${1:-help}" in
    login) shift; cmd_login "$@" ;;
    logout) cmd_logout ;;
    config)
      case "${2:-}" in
        show) shift 2; cmd_config_show "$@" ;;
        *) die "Usage: sb config show [--show-token]" ;;
      esac
      ;;
    status) cmd_status ;;
    vm)
      case "${2:-}" in
        list) cmd_vm_list ;;
        create) shift 2; cmd_vm_create "$@" ;;
        get) shift 2; cmd_vm_get "$@" ;;
        delete) shift 2; cmd_vm_delete "$@" ;;
        snapshot) shift 2; cmd_vm_snapshot "$@" ;;
        wait) shift 2; cmd_vm_wait "$@" ;;
        *) die "Usage: sb vm [list|create|get|delete|snapshot|wait]" ;;
      esac
      ;;
    connect) shift; cmd_connect "$@" ;;
    template)
      case "${2:-}" in
        list) cmd_template_list ;;
        delete) shift 2; cmd_template_delete "$@" ;;
        *) die "Usage: sb template [list|delete]" ;;
      esac
      ;;
    version|--version|-v) cmd_version ;;
    help|--help|-h) cmd_help ;;
    *) die "Unknown command: $1. Try: sb help" ;;
  esac
}

main "$@"
